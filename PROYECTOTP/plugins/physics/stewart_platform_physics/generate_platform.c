//
// File:         generate_platform.c
// Date:         October 30, 2008
// Description:  .wbt file generator for simple "stewart platforms"
//               This generator automatically computes the translations and rotations of the
//               6 pistons of the stewart platform, which is a rather difficult task to compute manually.
//               In addition the generator automatically handles DEF/USE in order to minimize
//               the amount of generated code .wbt.
// Author:       Yvan Bourquin - www.cyberbotics.com
//

#include <stdio.h>
#include <math.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

static int tab = 0;
static FILE *output = NULL;

inline double deg2rad(double deg) {
  return deg / 180.0 * M_PI;
}

// euler-axes-angle (vrml) to quaternion conversion
static void vrml_to_q(const double v[4], double q[4]) {
  double l = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
  if (l > 0.0) {
    q[0] = cos(v[3] / 2);
    l = sin(v[3] / 2) / sqrt(l);
    q[1] = v[0] * l;
    q[2] = v[1] * l;
    q[3] = v[2] * l;
  }
  else {
    q[0] = 1;
    q[1] = 0;
    q[2] = 0;
    q[3] = 0;
  }
}

// quaternion to euler-axes-angle (vrml) conversion
static void q_to_vrml(const double q[4], double v[4]) {

  // if q[0] > 1, acos will return nan
  // if this actually happens we should normalize the quaternion here 
  v[3] = 2.0 * acos(q[0]);
  if (v[3] < 0.0001) {
    // if e[3] close to zero then direction of axis not important
    v[0] = 0.0;
    v[1] = 1.0;
    v[2] = 0.0;
  }
  else {
    // normalise axes
    double n = sqrt(q[1] * q[1] + q[2] * q[2] + q[3] * q[3]);
    v[0] = q[1] / n;
    v[1] = q[2] / n;
    v[2] = q[3] / n;
  }
}

// quaternion multiplication (combining rotations)
static void q_mult(double qa[4], const double qb[4], const double qc[4]) {
  qa[0] = qb[0]*qc[0] - qb[1]*qc[1] - qb[2]*qc[2] - qb[3]*qc[3];
  qa[1] = qb[0]*qc[1] + qb[1]*qc[0] + qb[2]*qc[3] - qb[3]*qc[2];
  qa[2] = qb[0]*qc[2] + qb[2]*qc[0] + qb[3]*qc[1] - qb[1]*qc[3];
  qa[3] = qb[0]*qc[3] + qb[3]*qc[0] + qb[1]*qc[2] - qb[2]*qc[1];
}

// .wbt output with tabulation
static void tprintf(const char *format, ...) {
  va_list args;
  va_start(args, format);
  int i;
  for (i = 0; i < tab; i++)
    fprintf(output, "  ");
  vfprintf(output, format, args);
  fprintf(output, "\n");
  va_end(args);
}

// world file header
static void printHeader() {
  tprintf("#VRML_SIM V5.0 utf8");
  tprintf("");
  tprintf("WorldInfo {");
  tprintf("  info [");
  tprintf("    \"Example of Stewart platform demonstrating the combination of linear motors (Servo) and physics plugin in Webots.\"");
  tprintf("    \"The model was automatically generated by the generate_platform.c program located in webots/projects/samples/demos/plugins/physics/stewart_platform_physics.\"");
  tprintf("    \"Author: Yvan Bourquin, Cyberbotics Ltd.\"");
  tprintf("    \"Date: October 30, 2008\"");
  tprintf("  ]");
  tprintf("  title \"Stewart Platform\"");
  tprintf("  physics \"stewart_platform_physics\"");
  tprintf("  basicTimeStep 4");
  tprintf("  runRealTime TRUE");
  tprintf("}");
  tprintf("Viewpoint {");
  tprintf("  orientation 0.0540509 0.985048 0.163581 3.77093");
  tprintf("  position -6.71004 6.00527 -8.98845");
  tprintf("}");
  tprintf("Background {");
  tprintf("  skyColor [");
  tprintf("    0.4 0.7 1");
  tprintf("  ]");
  tprintf("}");
  tprintf("DirectionalLight {");
  tprintf("  ambientIntensity 0.5");
  tprintf("  direction 0.2 -1 0.1");
  tprintf("}");
  tprintf("MetricFloor {");
  tprintf("}");
}

// top platform
static void printUpperPlatform() {
  tprintf("DEF UPPER_PLATFORM Servo {");
  tprintf("  translation 0 2.7 0");   // upper platform elevation
  tprintf("  children [");
  tprintf("    DEF UPPER_PLATFORM_SHAPE Shape {");
  tprintf("      appearance Appearance {");
  tprintf("        material Material {");
  tprintf("          diffuseColor 0.12 0.56 1");
  tprintf("        }");
  tprintf("      }");
  tprintf("      geometry Cylinder {");
  tprintf("        height 0.1");
  tprintf("        radius 1.3");   // upper platform radius
  tprintf("        subdivision 20");
  tprintf("      }");
  tprintf("    }");
  tprintf("  ]");
  tprintf("  boundingObject USE UPPER_PLATFORM_SHAPE");
  tprintf("  physics Physics {");
  tprintf("    density 10");
  tprintf("  }");
  tprintf("  type \"none\"");
  tprintf("}");
}

// single piston
static void printPiston(int index, const double trans[3], const double rotation[4]) {
  tprintf("DEF LOWER_PISTON_%d Servo {", index);
  tprintf("  translation %g %g %g", trans[0], trans[1], trans[2]);
  tprintf("  rotation %g %g %g %g", rotation[0], rotation[1], rotation[2], rotation[3]);
  tprintf("  children [");
  tprintf("    DEF UPPER_PISTON_%d Servo {", index);
  tprintf("      translation 0 1.7 0");
  tprintf("      rotation 1 0 0 1.5708");
  tprintf("      children [");

  static int count1 = 0;
  if (count1++)
    tprintf("        USE TWO_CYLS_GROUP");
  else {
    tprintf("        DEF TWO_CYLS_GROUP Group {");
    tprintf("          children [");
    tprintf("            DEF SHORT_CYL_TRANS Transform {");
    tprintf("              rotation 1 0 0 1.5708");
    tprintf("              children [");
    tprintf("                Shape {");
    tprintf("                  geometry Cylinder {");   // upper piston cylinder
    tprintf("                    height 0.2");
    tprintf("                    radius 0.1");
    tprintf("                  }");
    tprintf("                }");
    tprintf("              ]");
    tprintf("            }");
    tprintf("            DEF THIN_CYL_TRANS Transform {");
    tprintf("              translation 0 0 0.7");
    tprintf("              rotation 1 0 0 1.5708");
    tprintf("              children [");
    tprintf("                Shape {");
    tprintf("                  appearance Appearance {");  // metal appearance
    tprintf("                    material Material {");
    tprintf("                      diffuseColor 0.901961 0.901961 0.980392");
    tprintf("                      shininess 1");
    tprintf("                      specularColor 0.901961 0.901961 0.980392");
    tprintf("                    }");
    tprintf("                  }");
    tprintf("                  geometry Cylinder {");
    tprintf("                    height 1.4");
    tprintf("                    radius 0.07");
    tprintf("                  }");
    tprintf("                }");
    tprintf("              ]");
    tprintf("            }");
    tprintf("          ]");
    tprintf("        }");
  }

  static int count2 = 0;
  if (count2++)
    tprintf("        USE UPPER_BALL_TRANS");
  else {
    tprintf("        DEF UPPER_BALL_TRANS Transform {");
    tprintf("          translation 0 0 -0.2");   // this hard-coded translation must match the one in stewart_platform_physics.c
    tprintf("          children [");
    tprintf("            Shape {");
    tprintf("              geometry Sphere {");
    tprintf("                radius 0.1");
    tprintf("              }");
    tprintf("            }");
    tprintf("          ]");
    tprintf("        }");
  }

  tprintf("      ]");
  tprintf("      name \"piston%d\"", index);
  tprintf("      boundingObject USE TWO_CYLS_GROUP");
  tprintf("      physics Physics {");
  tprintf("        density 10");
  tprintf("      }");
  tprintf("      type \"linear\"");
  tprintf("      maxForce 1000");
  tprintf("      minPosition -0.4");  // min/max linear motor motion
  tprintf("      maxPosition 0.4");
  tprintf("    }");

  static int count3 = 0;
  if (count3++)
    tprintf("    USE LONG_CYL_SHAPE");
  else {
    tprintf("    DEF LONG_CYL_SHAPE Shape {");
    tprintf("      geometry Cylinder {");
    tprintf("        height 1.6");
    tprintf("        radius 0.1");
    tprintf("      }");
    tprintf("    }");
  }

  static int count4 = 0;
  if (count4++)
    tprintf("    USE LOWER_BALL");
  else {
    tprintf("    DEF LOWER_BALL Transform {");
    tprintf("      translation 0 -0.9 0");   // this hard-coded translation must match the one in stewart_platform_physics.c
    tprintf("      children [");
    tprintf("        Shape {");
    tprintf("          geometry Sphere {");
    tprintf("            radius 0.1");
    tprintf("          }");
    tprintf("        }");
    tprintf("      ]");
    tprintf("    }");
  }

  tprintf("  ]");
  tprintf("  boundingObject USE LONG_CYL_SHAPE");
  tprintf("  physics Physics {");
  tprintf("    density 10");
  tprintf("  }");
  tprintf("  type \"none\"");
  tprintf("}");
}

// print the 6 pistons of the stewart platform
static void printPistons() {
  int i;
  for (i = 0; i < 6; i++) {

    // piston y-axis rotation
    // use 0, 120 and 240 degrees rotation, +/- 10 degrees for even/odd piston index
    double beta = i / 2 * 120 + (i % 2 ? -10 : +10 -180);
    double y_rot[4] = { 0, 1, 0, deg2rad(beta) };

    // all piston have a 30 degrees inclination with respect to the floor
    double z_rot[4] = { 0, 0, 1, deg2rad(30) };

    // convert vrml to quaternion representation
    double q1[4], q2[4];
    vrml_to_q(y_rot, q1);
    vrml_to_q(z_rot, q2);

    // combine two quaternions into one
    double q3[4];
    q_mult(q3, q1, q2);

    // convert quaternion to vrml
    double rot[4];
    q_to_vrml(q3, rot);

    // use trigonometric circle to compute piston translation
    // all piston centers are on the same circle of radius RADIUS
    // alpha is the angle of the piston center as seen from the center of the circle
    const double RADIUS = 1.6;
    double alpha = deg2rad(i / 2 * 120 + (i % 2 ? +45 : -45));
    double trans[3] = { sin(alpha) * RADIUS, 0.9, cos(alpha) * RADIUS };

    // print piston
    printPiston(i, trans, rot);
  }
}

// print stewart platform
static void printRobot() {
  tprintf("DEF STEWART_PLATFORM Robot {");
  tprintf("  translation 0 0.05 0");   // robot elevation
  tprintf("  children [");
  tprintf("    DEF CYLINDER_BODY Shape {");
  tprintf("      appearance Appearance {");
  tprintf("        material Material {");
  tprintf("          diffuseColor 0.12 0.56 1");
  tprintf("        }");
  tprintf("      }");
  tprintf("      geometry Cylinder {");  // lower platform cylinder
  tprintf("        height 0.1");
  tprintf("        radius 2.3");
  tprintf("        subdivision 20");
  tprintf("      }");
  tprintf("    }");

  tab += 2;
  printPistons();
  printUpperPlatform();
  tab -= 2;

  tprintf("  ]");
  tprintf("  boundingObject USE CYLINDER_BODY");
  tprintf("  physics Physics {");
  tprintf("    density 10");
  tprintf("    coulombFriction 100");  // more stable on the floor
  tprintf("  }");
  tprintf("  controller \"stewart_platform\"");
  tprintf("  selfCollision TRUE");   // optional
  tprintf("}");
}

// print one yellow box at specified elevation
static void printBox(double elevation) {

  tprintf("DEF YELLOW_BOX Solid {");
  tprintf("  translation 0 %g 0", elevation);
  tprintf("  children [");

 static int count = 0;
  if (count++)
    tprintf("    USE BOX_SHAPE");
  else {
    tprintf("    DEF BOX_SHAPE Shape {");
    tprintf("      appearance Appearance {");
    tprintf("        material Material {");
    tprintf("          diffuseColor 1 1 0");
    tprintf("        }");
    tprintf("      }");
    tprintf("      geometry Box {");
    tprintf("        size 0.4 0.4 0.4");
    tprintf("      }");
    tprintf("    }");
  }

  tprintf("  ]");
  tprintf("  boundingObject USE BOX_SHAPE");
  tprintf("  physics Physics {");
  tprintf("    density 100");
  tprintf("  }");
  tprintf("}");
}

int main() {
  output = fopen("../../../worlds/stewart_platform.wbt", "w");

  printHeader(); // print world header
  printRobot();  // printf stewart platform

  // print yellow boxes
  int i;
  for (i = 0; i < 5; i++)
    printBox(3.0 + 0.5 * i);

  fclose(output);
  return 0;
}
